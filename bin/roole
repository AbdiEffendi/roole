#!/usr/bin/env node
'use strict';

var Q = require('q');
var fs = require('fs');
var qfs = {
	stat: Q.denodeify(fs.stat),
	readFile: Q.denodeify(fs.readFile),
	readdir: Q.denodeify(fs.readdir),
	writeFile: Q.denodeify(fs.writeFile)
};
var path = require('path');
var format = require('util').format;
var mkdirp = require('mkdirp');
var qmkdirp = Q.denodeify(mkdirp);
var program = require('commander');
var _ = require('../lib/helper');
var roole = require('../lib/roole');

program
	.version(roole.version, '-v, --version')
	.usage('[options] [file|dir ...]')
	.option('-p, --print', 'Output compiled CSS to stdout')
	.option('-o, --out <dir>', 'Write compiled files to <dir>')
	.option('-w, --watch', 'Watch files and re-compile if changed')
	.option('-f, --force', 'Create files even when compile to empty string')
	.option('    --prefix <names>', 'Space-separated vendor names to use for prefixing')
	.option('    --indent <str>', 'Indentation string to use in CSS')
	.option('    --precision <num>', 'Max number of decimal digits to use in CSS')
	.option('    --skip-prefixed', 'Not generate prefixed rule that already exists')
	.parse(process.argv);

var options = _.mixin({}, program, {prettyError: true});

if (!program.args.length) {
	readStdin().then(compile).done(console.log);
} else if (!program.watch) {
	resolveFiles(program.args).then(compileFiles).done(outputFiles);
} else {
	var files;
	resolveFiles(program.args).then(function (f) {
		files = f;
		return files;
	}).then(compileFiles).then(outputFiles).catch(function (error) {
		printError(error);
		return files;
	}).done(watchFiles);
}

function readStdin() {
	var deferred = Q.defer();
	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function(chunk) { stdin += chunk; });
	process.stdin.on('end', function(){
		deferred.resolve(stdin);
	});
	process.stdin.on('error', function (error) {
		deferred.reject(error);
	});
	return deferred.promise;
}

function compile(input, opts) {
	var deferred = Q.defer();
	var resolver = deferred.makeNodeResolver();
	roole.compile(input, opts || options, resolver);
	return deferred.promise;
}

function resolveFiles(filenames, root, rooOnly) {
	var stats = filenames.map(function (filename) {
		return qfs.stat(filename);
	});
	return Q.all(stats).then(function (stats) {
		var files = filenames.map(function (filename, i) {
			if (stats[i].isFile() && (!rooOnly || /\.roo$/.test(filename))) {
				return resolveFile(filename, root);
			} else if (stats[i].isDirectory()) {
				return resolveDir(filename, root);
			}
		}).filter(function (file) {
			return file;
		});
		return Q.all(files).then(function (files) {
			return _.flatten(files);
		});
	});
}

function resolveFile(filename, root) {
	var out = filename.replace(/\.roo$|$/, '.css');
	if (program.out) {
		out = root ? path.relative(root, out) : path.basename(out);
		out = path.join(program.out, out);
	}
	return qfs.readFile(filename, 'utf8').then(function (content) {
		return {
			input: {name: filename, content: content},
			output: {name: out}
		};
	});
}

function resolveDir(dirname, root) {
	return qfs.readdir(dirname).then(function (filenames) {
		return filenames.map(function (filename) {
			return path.join(dirname, filename);
		});
	}).then(function (filenames) {
		return resolveFiles(filenames, root || dirname, true);
	});
}

function compileFiles(files) {
	files = files.map(compileFile);
	return Q.all(files);
}

function compileFile(file) {
	var opts = _.mixin({}, options, {filename: file.input.name});
	return compile(file.input.content, opts).then(function (output) {
		file.output.content = output;
		return file;
	});
}

function outputFiles(files) {
	if (program.print) {
		var content = files.filter(function(file) {
			return file.output.content;
		}).map(function(file) {
			return file.output.content;
		}).join('\n\n');
		console.log(content);
		return files;
	}
	return writeFiles(files);
}

function printError(error) {
	console.error();
	console.error(error.name + ':', error.message);
}

function writeFiles(files) {
	files = files.map(writeFile);
	return Q.all(files);
}

function writeFile(file) {
	if (!file.output.content && !program.force) {
		printEmptyFileInfo(file);
		return file;
	}

	var dir = path.dirname(file.output.name);
	return qmkdirp(dir).then(function () {
		return qfs.writeFile(file.output.name, file.output.content);
	}).then(function () {
		printWriteInfo(file);
		return file;
	});
}

function printEmptyFileInfo(file) {
	var msg = '%d compiled to empty string, not writing to file';
	msg = format(msg, file.input.name);
	console.log((program.watch ? '  ' : 'INFO: ') + msg);
}

function printWriteInfo(file) {
	if (!program.watch) {
		return;
	}
	var msg = 'compiled %s to %s';
	msg = format(msg, file.input.name, file.output.name);
	console.log('  ' + msg);
}

function watchFiles(files) {
	printWatchedFiles(program.args);
	files.forEach(watchFile);
}

function watchFile(file) {
	fs.watchFile(file.input.name, {interval: 100}, function(curr, prev) {
		if (curr.mtime <= prev.mtime) {
			return;
		}
		var content = fs.readFileSync(file.input.name, 'utf8');
		file.input.content = content;
		compileFile(file).then(writeFile).catch(function (error) {
			printError(error);
		});
	});
}

function printWatchedFiles(filenames) {
	filenames.map(function(filename) {
		var stats = fs.statSync(filename);
		if (stats.isDirectory() && filename.slice(-1) !== '/') {
			filename += '/';
		}
		return filename;
	}).map(function (filename) {
		console.log('  watching', filename);
	});
}