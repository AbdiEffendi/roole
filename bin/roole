#!/usr/bin/env node
'use strict';

var fs = require('fs');
var path = require('path');
var mkdirp = require('mkdirp');
var program = require('commander');
var roole = require('../lib/roole');

program
	.version(roole.version, '-v, --version')
	.usage('[options] [file|dir ...]')
	.option('-p, --print', 'Output compiled CSS to stdout')
	.option('-o, --out <dir>', 'Write compiled files to <dir>')
	.option('-w, --watch', 'Watch files and re-compile if changed')
	.option('-f, --force', 'Create files even when compile to empty string')
	.option('    --prefix <names>', 'Space-separated vendor names to use for prefixing')
	.option('    --indent <str>', 'Indentation string to use in CSS')
	.option('    --precision <num>', 'Max number of decimal digits to use in CSS')
	.option('    --skip-prefixed', 'Not generate prefixed rule that already exists')
	.parse(process.argv);

var options = program;
options.prettyError = true;

if (!program.args.length) {
	compileStdin(console.log);
} else {
	var files = resolveFiles(program.args);
	compileFiles(files, outputFiles);
}

function compileStdin(callback) {
	var stdin = '';
	process.stdin.resume();
	process.stdin.setEncoding('utf8');
	process.stdin.on('data', function(chunk) { stdin += chunk; });
	process.stdin.on('end', function(){
		compile(stdin, options, callback);
	});
}

function compile(input, options, callback) {
	roole.compile(input, options, function(error, css) {
		if (!error) {
			return callback(css);
		}
		if (!program.watch) {
			throw error;
		}
		console.error(error.message);
		// FIXME: should not display compile to empty file warning
		callback('');
	});
}

function resolveFiles(filenames) {
	var files = [];
	filenames.forEach(function(filename) {
		var stat = fs.statSync(filename);
		if (stat.isFile()) {
			var file = resolveFile(filename);
			files.push(file);
		} else if (stat.isDirectory()) {
			var _files = resolveDir(filename);
			files = files.concat(_files);
		}
	});
	return files;
}

function resolveFile(filename) {
	var outputName = filename.replace(/\.roo$|$/, '.css');
	if (program.out) {
		var base = path.basename(outputName);
		outputName = path.join(program.out, base);
	}
	return {
		name: filename,
		outputName: outputName,
		content: fs.readFileSync(filename, 'utf8')
	};
}

function resolveDir(dirname, root) {
	if (!root) {
		root = dirname;
	}
	var files = [];
	var filenames = fs.readdirSync(dirname);
	filenames.map(function (filename) {
		return path.join(dirname, filename);
	}).forEach(function(filename) {
		var stat = fs.statSync(filename);
		if (stat.isFile() && path.extname(filename) === '.roo') {
			var file = resolveDirFile(filename, root);
			files.push(file);
		} else if (stat.isDirectory()) {
			var _files = resolveDir(filename, root);
			files = files.concat(_files);
		}
	});
	return files;
}

function resolveDirFile(filename, root) {
	var file = resolveFile(filename);
	if (program.out) {
		var outputName = filename.replace(/\.roo$|$/, '.css');
		outputName = path.relative(root, outputName);
		file.outputName = path.join(program.out, outputName);
	}
	return file;
}

function outputFiles(files) {
	if (program.print) {
		var content = files.filter(function(file) {
			return file.compiledContent;
		}).map(function(file) {
			return file.compiledContent;
		}).join('\n\n');
		return console.log(content);
	}

	writeFiles(files);
	if (program.watch) {
		watchFiles(files);
	}
}

function compileFiles(files, callback) {
	var length = files.length;
	files.forEach(function(file) {
		compileFile(file, function() {
			if (!--length) {
				callback(files);
			}
		});
	});
}

function compileFile(file, callback) {
	options.filename = file.name;
	compile(file.content, options, function (css) {
		file.compiledContent = css;
		callback(file);
	});
}

function writeFiles(files) {
	files.forEach(function(file) {
		writeFile(file);
	});
}

function writeFile(file, watching) {
	if (!file.compiledContent && !program.force) {
		if (!program.watch) {
			console.log('INFO:', file.name, 'compiles to empty string, not writing to file');
		} else if (watching) {
			console.log('  compiled', file.name, 'to empty string, not writing to file');
		}
	} else {
		var dir = path.dirname(file.outputName);
		mkdirp.sync(dir);
		fs.writeFileSync(file.outputName, file.compiledContent);

		if (program.watch && watching) {
			console.log('  compiled', file.name, 'to', file.outputName);
		}
	}
}

function watchFiles(files) {
	program.args.forEach(function(filename) {
		var stat = fs.statSync(filename);
		if (stat.isDirectory() && filename.slice(-1) !== '/') {
			filename += '/';
		}
		console.log('  watching', filename);
	});
	files.forEach(function(file) {
		watchFile(file);
	});
}

function watchFile(file) {
	fs.watchFile(file.name, {interval: 100}, function(curr, prev) {
		if (curr.mtime <= prev.mtime) {
			return;
		}
		file.content = fs.readFileSync(file.name, 'utf8');
		compileFile(file, function() {
			writeFile(file, true);
		});
	});
}