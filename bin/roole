#!/usr/bin/env node

var fs = require('fs')
var path = require('path')
var mkdirp = require('mkdirp')
var roole = require('../lib/roole')

var usage = [
	'',
	'  Usage: roole [options] [file|dir ...]',
	'',
	'  Options:',
	'',
	'    -p, --print      Output compiled CSS to stdout ' ,
	'    -o, --out <dir>  Write compiled files to <dir>',
	'    -w, --watch      Watch files and re-compile if changed',
	'    -f, --force      Create files even when compile to empty string',
	'    -v, --version    Display the version number',
	'    -h, --help       Display this help message',
].join('\n')

var options = {}
var filePaths = []

var args = process.argv.slice(2)
while (args.length) {
	var arg = args.shift()
	switch (arg) {
	case '-h':
	case '--help':
		console.error(usage)
		process.exit(1)
	case '-v':
	case '--version':
		console.error(roole.version)
		process.exit(2)
	case '-p':
	case '--print':
		options.print = true
		break
	case '-o':
	case '--out':
		options.out = args.shift()
		break
	case '-w':
	case '--watch':
		options.watch = true
		break
	case '-f':
	case '--force':
		options.force = true
		break
	default:
		filePaths.push(arg)
	}
}

if (!filePaths.length) {
	compileStdin(function(content) {
		console.log(content)
	})
	return
}

var files = resolveFiles(filePaths)
var watching = false

compileFiles(files, function() {
	if (options.print) {
		var content = files
			.filter(function(file) { return file.compiledContent })
			.map(function(file) { return file.compiledContent })
			.join('\n\n')

		console.log(content)
		return
	}

	writeFiles(files)

	if (options.watch) {
		filePaths.forEach(function(filePath) {
			var stat = fs.statSync(filePath)
			if (stat.isDirectory() && filePath.slice(-1) !== '/')
				filePath += '/'

			console.log('  watching', filePath)
		})
		watchFiles(files)
		watching = true
	}
})

function compileStdin(callback) {
	var stdin = ''
	process.stdin.setEncoding('utf8')
	process.stdin.on('data', function(chunk){ stdin += chunk })
	process.stdin.on('end', function(){
		roole.compile(stdin, options, function(error, css) {
			if (error)
				throw error

			callback(css)
		})
	})
}

function resolveFiles(filePaths, dirPath) {
	var files = []
	filePaths.forEach(function(filePath) {
		var stat = fs.statSync(filePath)
		if (stat.isFile()) {
			var file = {
				path: filePath,
				content: fs.readFileSync(filePath, 'utf8')
			}

			if (!options.out) {
				file.outputPath = file.path
			} else {
				if (!dirPath) {
					var base = path.basename(file.path)
					file.outputPath = path.join(options.out, base)
				} else {
					var subpath = path.relative(dirPath, file.path)
					file.outputPath = path.join(options.out, subpath)
				}
			}
			file.outputPath = file.outputPath.replace(/\.roo$|$/, '.css')

			files.push(file)
		} else if (stat.isDirectory()) {
			var dir = filePath
			var filePaths = fs.readdirSync(dir)
			filePaths = filePaths.map(function(filePath) {
				return path.join(dir, filePath)
			}).filter(function(filePath) {
				var stat = fs.statSync(filePath)
				if (stat.isFile())
					return /\.roo$/.test(filePath)

				return stat.isDirectory()
			})
			files = files.concat(resolveFiles(filePaths, dirPath || filePath))
		}
	})
	return files
}

function compileFiles(files, callback) {
	var i = 0
	var length = files.length

	files.forEach(function(file) {
		compileFile(file, function() {
			if (++i === length)
				callback(files)
		})
	})
}

function compileFile(file, callback) {
	roole.compile(file.content, {
		prettyError: true,
		filePath: file.path
	}, function(error, css) {
		if (error)
			throw error

		file.compiledContent = css

		callback(file)
	})
}

function writeFiles(files) {
	files.forEach(writeFile)
}

function writeFile(file) {
	var dir = path.dirname(file.outputPath)
	if (!fs.existsSync(dir))
		mkdirp.sync(dir)
	fs.writeFileSync(file.outputPath, file.compiledContent)

	if (!options.force && !file.compiledContent) {
		if (!options.watch)
			console.log('INFO:', file.path, 'compiles to empty string, not writing to file')
		else if (watching)
			console.log('  compiled', file.path, 'to empty string, not writing to file')
	} else {
		if (options.watch && watching)
			console.log('  compiled', file.path, 'to', file.outputPath)
	}
}

function watchFiles(files) {
	files.forEach(watchFile)
}

function watchFile(file) {
	fs.watchFile(file.path, {interval: 100}, function(curr, prev) {
		if (curr.mtime <= prev.mtime)
			return

		compileFile(file, writeFile)
	})
}